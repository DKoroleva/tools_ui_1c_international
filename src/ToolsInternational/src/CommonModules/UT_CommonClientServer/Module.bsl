#Область Переменные

#КонецОбласти

#Область ДинамическийСписок

////////////////////////////////////////////////////////////////////////////////
// Функции для работы с отборами и параметрами динамических списков.
//

// Найти элемент или группу отбора по заданному имени поля или представлению.
//
// Параметры:
//  ОбластьПоиска - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных,
//                  ГруппаЭлементовОтбораКомпоновкиДанных - контейнер
//                  с элементами и группами отбора, например Список.Отбор или группа в отборе.
//  ИмяПоля       - Строка - имя поля компоновки (не используется для групп).
//  Представление - Строка - представление поля компоновки.
//
// Возвращаемое значение:
//  Массив - коллекция отборов.
//
Function НайтиЭлементыИГруппыОтбора(Знач ОбластьПоиска, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено) Export

	Если ValueIsFilled(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;

	МассивЭлементов = Новый Массив;

	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);

	Return МассивЭлементов;

EndFunction

// Добавить группу отбора в коллекцию КоллекцияЭлементов.
//
// Параметры:
//  КоллекцияЭлементов - ОтборКомпоновкиДанных, КоллекцияЭлементовОтбораКомпоновкиДанных,
//                       ГруппаЭлементовОтбораКомпоновкиДанных - контейнер
//                       с элементами и группами отбора, например Список.Отбор или группа в отборе.
//  Представление      - Строка - представление группы.
//  ТипГруппы          - ТипГруппыЭлементовОтбораКомпоновкиДанных - тип группы.
//
// Возвращаемое значение:
//  ГруппаЭлементовОтбораКомпоновкиДанных - группа отбора.
//
Function СоздатьГруппуЭлементовОтбора(Знач КоллекцияЭлементов, Представление, ТипГруппы) Export

	Если ТипЗнч(КоллекцияЭлементов) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		КоллекцияЭлементов = КоллекцияЭлементов.Элементы;
	КонецЕсли;

	ГруппаЭлементовОтбора = НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление);
	Если ГруппаЭлементовОтбора = Неопределено Тогда
		ГруппаЭлементовОтбора = КоллекцияЭлементов.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
	Иначе
		ГруппаЭлементовОтбора.Элементы.Очистить();
	КонецЕсли;

	ГруппаЭлементовОтбора.Представление = Представление;
	ГруппаЭлементовОтбора.Применение = ТипПримененияОтбораКомпоновкиДанных.Элементы;
	ГруппаЭлементовОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	ГруппаЭлементовОтбора.ТипГруппы = ТипГруппы;
	ГруппаЭлементовОтбора.Использование = Истина;

	Return ГруппаЭлементовОтбора;

EndFunction

// Добавить элемент компоновки в контейнер элементов компоновки.
//
// Параметры:
//  ОбластьДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                 например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент компоновки.
//
Function ДобавитьЭлементКомпоновки(ОбластьДобавления, Знач ИмяПоля, Знач ВидСравнения, Знач ПравоеЗначение = Неопределено,
	Знач Представление = Неопределено, Знач Использование = Неопределено, Знач РежимОтображения = Неопределено,
	Знач ИдентификаторПользовательскойНастройки = Неопределено) Export

	Элемент = ОбластьДобавления.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
	Элемент.ВидСравнения = ВидСравнения;

	Если РежимОтображения = Неопределено Тогда
		Элемент.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	Иначе
		Элемент.РежимОтображения = РежимОтображения;
	КонецЕсли;

	Если ПравоеЗначение <> Неопределено Тогда
		Элемент.ПравоеЗначение = ПравоеЗначение;
	КонецЕсли;

	Если Представление <> Неопределено Тогда
		Элемент.Представление = Представление;
	КонецЕсли;

	Если Использование <> Неопределено Тогда
		Элемент.Использование = Использование;
	КонецЕсли;

	// Важно: установка идентификатора должна выполняться
	// в конце настройки элемента, иначе он будет скопирован
	// в пользовательские настройки частично заполненным.
	Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
	ИначеЕсли Элемент.РежимОтображения <> РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		Элемент.ИдентификаторПользовательскойНастройки = ИмяПоля;
	КонецЕсли;

	Return Элемент;

EndFunction

// Изменить элемент отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьПоиска - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                             например Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  Представление           - Строка - представление элемента компоновки данных.
//  ПравоеЗначение          - Произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
// Возвращаемое значение:
//  Число - количество измененных элементов.
//
Function ИзменитьЭлементыОтбора(ОбластьПоиска, Знач ИмяПоля = Неопределено, Знач Представление = Неопределено,
	Знач ПравоеЗначение = Неопределено, Знач ВидСравнения = Неопределено, Знач Использование = Неопределено,
	Знач РежимОтображения = Неопределено, Знач ИдентификаторПользовательскойНастройки = Неопределено) Export

	Если ValueIsFilled(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;

	МассивЭлементов = Новый Массив;

	НайтиРекурсивно(ОбластьПоиска.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);

	Для Каждого Элемент Из МассивЭлементов Цикл
		Если ИмяПоля <> Неопределено Тогда
			Элемент.ЛевоеЗначение = Новый ПолеКомпоновкиДанных(ИмяПоля);
		КонецЕсли;
		Если Представление <> Неопределено Тогда
			Элемент.Представление = Представление;
		КонецЕсли;
		Если Использование <> Неопределено Тогда
			Элемент.Использование = Использование;
		КонецЕсли;
		Если ВидСравнения <> Неопределено Тогда
			Элемент.ВидСравнения = ВидСравнения;
		КонецЕсли;
		Если ПравоеЗначение <> Неопределено Тогда
			Элемент.ПравоеЗначение = ПравоеЗначение;
		КонецЕсли;
		Если РежимОтображения <> Неопределено Тогда
			Элемент.РежимОтображения = РежимОтображения;
		КонецЕсли;
		Если ИдентификаторПользовательскойНастройки <> Неопределено Тогда
			Элемент.ИдентификаторПользовательскойНастройки = ИдентификаторПользовательскойНастройки;
		КонецЕсли;
	КонецЦикла;

	Return МассивЭлементов.Количество();

EndFunction

// Удалить элементы отбора с заданным именем поля или представлением.
//
// Параметры:
//  ОбластьУдаления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                               например, Список.Отбор или группа в отборе..
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбора(Знач ОбластьУдаления, Знач ИмяПоля = Неопределено,
	Знач Представление = Неопределено) Export

	Если ValueIsFilled(ИмяПоля) Тогда
		ЗначениеПоиска = Новый ПолеКомпоновкиДанных(ИмяПоля);
		СпособПоиска = 1;
	Иначе
		СпособПоиска = 2;
		ЗначениеПоиска = Представление;
	КонецЕсли;

	МассивЭлементов = Новый Массив;

	НайтиРекурсивно(ОбластьУдаления.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);

	Для Каждого Элемент Из МассивЭлементов Цикл
		Если Элемент.Родитель = Неопределено Тогда
			ОбластьУдаления.Элементы.Удалить(Элемент);
		Иначе
			Элемент.Родитель.Элементы.Удалить(Элемент);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

// Добавить или заменить существующий элемент отбора.
//
// Параметры:
//  ОбластьПоискаДобавления - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                     например, Список.Отбор или группа в отборе.
//  ИмяПоля                 - Строка - имя поля компоновки данных (заполняется всегда).
//  ПравоеЗначение          - произвольный - сравниваемое значение.
//  ВидСравнения            - ВидСравненияКомпоновкиДанных - вид сравнения.
//  Представление           - Строка - представление элемента компоновки данных.
//  Использование           - Булево - использование элемента.
//  РежимОтображения        - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - режим отображения.
//  ИдентификаторПользовательскойНастройки - Строка - см. ОтборКомпоновкиДанных.ИдентификаторПользовательскойНастройки
//                                                    в синтакс-помощнике.
//
Процедура УстановитьЭлементОтбора(ОбластьПоискаДобавления, Знач ИмяПоля, Знач ПравоеЗначение = Неопределено,
	Знач ВидСравнения = Неопределено, Знач Представление = Неопределено, Знач Использование = Неопределено,
	Знач РежимОтображения = Неопределено, Знач ИдентификаторПользовательскойНастройки = Неопределено) Export

	ЧислоИзмененных = ИзменитьЭлементыОтбора(ОбластьПоискаДобавления, ИмяПоля, Представление, ПравоеЗначение,
		ВидСравнения, Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);

	Если ЧислоИзмененных = 0 Тогда
		Если ВидСравнения = Неопределено Тогда
			Если ТипЗнч(ПравоеЗначение) = Тип("Массив") Или ТипЗнч(ПравоеЗначение) = Тип("ФиксированныйМассив")
				Или ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
				ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
			Иначе
				ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
			КонецЕсли;
		КонецЕсли;
		Если РежимОтображения = Неопределено Тогда
			РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
		КонецЕсли;
		ДобавитьЭлементКомпоновки(ОбластьПоискаДобавления, ИмяПоля, ВидСравнения, ПравоеЗначение, Представление,
			Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);
	КонецЕсли;

КонецПроцедуры

// Добавить или заменить существующий элемент отбора динамического списка.
//
// Параметры:
//   ДинамическийСписок - ДинамическийСписок - список, в котором требуется установить отбор.
//   ИмяПоля            - Строка - поле, по которому необходимо установить отбор.
//   ПравоеЗначение     - Произвольный - значение отбора.
//       Необязательный. Значение по умолчанию Неопределено.
//       Внимание! Если передать Неопределено, то значение не будет изменено.
//   ВидСравнения  - ВидСравненияКомпоновкиДанных - условие отбора.
//   Представление - Строка - представление элемента компоновки данных.
//       Необязательный. Значение по умолчанию Неопределено.
//       Если указано, то выводится только флажок использования с указанным представлением (значение не выводится).
//       Для очистки (чтобы значение снова выводилось) следует передать пустую строку.
//   Использование - Булево - флажок использования этого отбора.
//       Необязательный. Значение по умолчанию: Неопределено.
//   РежимОтображения - РежимОтображенияЭлементаНастройкиКомпоновкиДанных - способ отображения этого отбора
//                                                                          пользователю.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ - В группе быстрых настроек над списком.
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Обычный       - В настройка списка (в подменю Еще).
//       * РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный   - Запретить пользователю менять этот отбор.
//   ИдентификаторПользовательскойНастройки - Строка - Уникальный идентификатор этого отбора.
//       Используется для связи с пользовательскими настройками.
//
Процедура УстановитьЭлементОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля, ПравоеЗначение = Неопределено,
	ВидСравнения = Неопределено, Представление = Неопределено, Использование = Неопределено,
	РежимОтображения = Неопределено, ИдентификаторПользовательскойНастройки = Неопределено) Export

	Если РежимОтображения = Неопределено Тогда
		РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный;
	КонецЕсли;

	Если РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор;
	Иначе
		ОтборДинамическогоСписка = ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор;
	КонецЕсли;

	УстановитьЭлементОтбора(ОтборДинамическогоСписка, ИмяПоля, ПравоеЗначение, ВидСравнения, Представление,
		Использование, РежимОтображения, ИдентификаторПользовательскойНастройки);

КонецПроцедуры

// Удалить элемент группы отбора динамического списка.
//
// Параметры:
//  ДинамическийСписок - ДинамическийСписок - реквизит формы, для которого требуется установить отбор.
//  ИмяПоля         - Строка - имя поля компоновки (не используется для групп).
//  Представление   - Строка - представление поля компоновки.
//
Процедура УдалитьЭлементыГруппыОтбораДинамическогоСписка(ДинамическийСписок, ИмяПоля = Неопределено,
	Представление = Неопределено) Export

	УдалитьЭлементыГруппыОтбора(ДинамическийСписок.КомпоновщикНастроек.ФиксированныеНастройки.Отбор, ИмяПоля,
		Представление);

	УдалитьЭлементыГруппыОтбора(ДинамическийСписок.КомпоновщикНастроек.Настройки.Отбор, ИмяПоля, Представление);

КонецПроцедуры

// Установить или обновить значение параметра ИмяПараметра динамического списка Список.
//
// Параметры:
//  Список          - ДинамическийСписок - реквизит формы, для которого требуется установить параметр.
//  ИмяПараметра    - Строка             - имя параметра динамического списка.
//  Значение        - Произвольный        - новое значение параметра.
//  Использование   - Булево             - признак использования параметра.
//
Процедура УстановитьПараметрДинамическогоСписка(Список, ИмяПараметра, Значение, Использование = Истина) Export

	ЗначениеПараметраКомпоновкиДанных = Список.Параметры.НайтиЗначениеПараметра(
		Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Если ЗначениеПараметраКомпоновкиДанных <> Неопределено Тогда
		Если Использование И ЗначениеПараметраКомпоновкиДанных.Значение <> Значение Тогда
			ЗначениеПараметраКомпоновкиДанных.Значение = Значение;
		КонецЕсли;
		Если ЗначениеПараметраКомпоновкиДанных.Использование <> Использование Тогда
			ЗначениеПараметраКомпоновкиДанных.Использование = Использование;
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

Function УстановитьЗначениеПараметраСКД(КомпоновщикНастроек, ИмяПараметра, ЗначениеПараметра,
	ИспользоватьНеЗаполненный = Истина) Export

	ПараметрУстановлен = Ложь;

	ПараметрКомпоновкиДанных = Новый ПараметрКомпоновкиДанных(ИмяПараметра);
	ЗначениеПараметраКомпоновкиДанных = КомпоновщикНастроек.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(
		ПараметрКомпоновкиДанных);
	Если ЗначениеПараметраКомпоновкиДанных <> Неопределено Тогда

		ЗначениеПараметраКомпоновкиДанных.Значение = ЗначениеПараметра;
		ЗначениеПараметраКомпоновкиДанных.Использование = ?(ИспользоватьНеЗаполненный, Истина, ValueIsFilled(
			ЗначениеПараметраКомпоновкиДанных.Значение));

		ПараметрУстановлен = Истина;

	КонецЕсли;

	Return ПараметрУстановлен;

EndFunction

Процедура НайтиРекурсивно(КоллекцияЭлементов, МассивЭлементов, СпособПоиска, ЗначениеПоиска)

	Для Каждого ЭлементОтбора Из КоллекцияЭлементов Цикл

		Если ТипЗнч(ЭлементОтбора) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда

			Если СпособПоиска = 1 Тогда
				Если ЭлементОтбора.ЛевоеЗначение = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			ИначеЕсли СпособПоиска = 2 Тогда
				Если ЭлементОтбора.Представление = ЗначениеПоиска Тогда
					МассивЭлементов.Добавить(ЭлементОтбора);
				КонецЕсли;
			КонецЕсли;
		Иначе

			НайтиРекурсивно(ЭлементОтбора.Элементы, МассивЭлементов, СпособПоиска, ЗначениеПоиска);

			Если СпособПоиска = 2 И ЭлементОтбора.Представление = ЗначениеПоиска Тогда
				МассивЭлементов.Добавить(ЭлементОтбора);
			КонецЕсли;

		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

// Выполняет поиск элемента отбора в коллекции по заданному представлению.
//
// Параметры:
//  КоллекцияЭлементов - КоллекцияЭлементовОтбораКомпоновкиДанных - контейнер с элементами и группами отбора,
//                                                                  например, Список.Отбор.Элементы или группа в отборе.
//  Представление - Строка - представление группы.
// 
// Возвращаемое значение:
//  ЭлементОтбораКомпоновкиДанных - элемент отбора.
//
Function НайтиЭлементОтбораПоПредставлению(КоллекцияЭлементов, Представление) Export

	ВозвращаемоеЗначение = Неопределено;

	Для Каждого ЭлементОтбора Из КоллекцияЭлементов Цикл
		Если ЭлементОтбора.Представление = Представление Тогда
			ВозвращаемоеЗначение = ЭлементОтбора;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Return ВозвращаемоеЗначение
EndFunction

Процедура СкопироватьЭлементы(ПриемникЗначения, ИсточникЗначения, ОчищатьПриемник = Истина) Export

	Если ТипЗнч(ИсточникЗначения) = Тип("УсловноеОформлениеКомпоновкиДанных") Или ТипЗнч(ИсточникЗначения) = Тип(
		"ВариантыПользовательскогоПоляВыборКомпоновкиДанных") Или ТипЗнч(ИсточникЗначения) = Тип(
		"ОформляемыеПоляКомпоновкиДанных") Или ТипЗнч(ИсточникЗначения) = Тип(
		"ЗначенияПараметровДанныхКомпоновкиДанных") Тогда
		СоздаватьПоТипу = Ложь;
	Иначе
		СоздаватьПоТипу = Истина;
	КонецЕсли;
	ПриемникЭлементов = ПриемникЗначения.Элементы;
	ИсточникЭлементов = ИсточникЗначения.Элементы;
	Если ОчищатьПриемник Тогда
		ПриемникЭлементов.Очистить();
	КонецЕсли;

	Для Каждого ЭлементИсточник Из ИсточникЭлементов Цикл

		Если ТипЗнч(ЭлементИсточник) = Тип("ЭлементПорядкаКомпоновкиДанных") Тогда
			// Элементы порядка добавляем в начало
			Индекс = ИсточникЭлементов.Индекс(ЭлементИсточник);
			ЭлементПриемник = ПриемникЭлементов.Вставить(Индекс, ТипЗнч(ЭлементИсточник));
		Иначе
			Если СоздаватьПоТипу Тогда
				ЭлементПриемник = ПриемникЭлементов.Добавить(ТипЗнч(ЭлементИсточник));
			Иначе
				ЭлементПриемник = ПриемникЭлементов.Добавить();
			КонецЕсли;
		КонецЕсли;

		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		// В некоторых коллекциях необходимо заполнить другие коллекции
		Если ТипЗнч(ИсточникЭлементов) = Тип("КоллекцияЭлементовУсловногоОформленияКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Поля, ЭлементИсточник.Поля);
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
			ЗаполнитьЭлементы(ЭлементПриемник.Оформление, ЭлементИсточник.Оформление);
		ИначеЕсли ТипЗнч(ИсточникЭлементов) = Тип("КоллекцияВариантовПользовательскогоПоляВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Отбор, ЭлементИсточник.Отбор);
		КонецЕсли;
		
		// В некоторых элементах коллекции необходимо заполнить другие коллекции
		Если ТипЗнч(ЭлементИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ГруппаВыбранныхПолейКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник, ЭлементИсточник);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыборКомпоновкиДанных") Тогда
			СкопироватьЭлементы(ЭлементПриемник.Варианты, ЭлементИсточник.Варианты);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ПользовательскоеПолеВыражениеКомпоновкиДанных") Тогда
			ЭлементПриемник.УстановитьВыражениеДетальныхЗаписей (ЭлементИсточник.ПолучитьВыражениеДетальныхЗаписей());
			ЭлементПриемник.УстановитьВыражениеИтоговыхЗаписей(ЭлементИсточник.ПолучитьВыражениеИтоговыхЗаписей());
			ЭлементПриемник.УстановитьПредставлениеВыраженияДетальныхЗаписей(
				ЭлементИсточник.ПолучитьПредставлениеВыраженияДетальныхЗаписей ());
			ЭлементПриемник.УстановитьПредставлениеВыраженияИтоговыхЗаписей(
				ЭлементИсточник.ПолучитьПредставлениеВыраженияИтоговыхЗаписей ());
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры
Процедура ЗаполнитьЭлементы(ПриемникЗначения, ИсточникЗначения, ПервыйУровень = Неопределено) Export

	Если ТипЗнч(ПриемникЗначения) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных") Тогда
		КоллекцияЗначений = ИсточникЗначения;
	Иначе
		КоллекцияЗначений = ИсточникЗначения.Элементы;
	КонецЕсли;

	Для Каждого ЭлементИсточник Из КоллекцияЗначений Цикл
		Если ПервыйУровень = Неопределено Тогда
			ЭлементПриемник = ПриемникЗначения.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		Иначе
			ЭлементПриемник = ПервыйУровень.НайтиЗначениеПараметра(ЭлементИсточник.Параметр);
		КонецЕсли;
		Если ЭлементПриемник = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		ЗаполнитьЗначенияСвойств(ЭлементПриемник, ЭлементИсточник);
		Если ТипЗнч(ЭлементИсточник) = Тип("ЗначениеПараметраКомпоновкиДанных") Тогда
			Если ЭлементИсточник.ЗначенияВложенныхПараметров.Количество() <> 0 Тогда
				ЗаполнитьЭлементы(ЭлементПриемник.ЗначенияВложенныхПараметров,
					ЭлементИсточник.ЗначенияВложенныхПараметров, ПриемникЗначения);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры


// Копирует настройки компоновки данных
//
// Параметры:
//	НастройкиПриемник	- НастройкиКомпоновкиДанных, НастройкиВложенногоОбъектаКомпоновкиДанных
//		ГруппировкаКомпоновкиДанных, ГруппировкаТаблицыКомпоновкиДанных, ГруппировкаДиаграммыКомпоновкиДанных,
//		ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных - коллекция настроек КД, куда копируются настройки
//	НастройкиИсточник	- НастройкиКомпоновкиДанных, НастройкиВложенногоОбъектаКомпоновкиДанных
//		ГруппировкаКомпоновкиДанных, ГруппировкаТаблицыКомпоновкиДанных, ГруппировкаДиаграммыКомпоновкиДанных,
//		ТаблицаКомпоновкиДанных, ДиаграммаКомпоновкиДанных - коллекция настроек КД, откуда копируются настройки.
//
Процедура СкопироватьНастройкиКомпоновкиДанных(НастройкиПриемник, НастройкиИсточник) Export
	
	Если НастройкиИсточник = Неопределено Тогда
		Return;
	КонецЕсли;
	
	Если ТипЗнч(НастройкиПриемник) = Тип("НастройкиКомпоновкиДанных") Тогда
		Для каждого Параметр Из НастройкиИсточник.ПараметрыДанных.Элементы Цикл
			ЗначениеПараметра = НастройкиПриемник.ПараметрыДанных.НайтиЗначениеПараметра(Параметр.Параметр);
			Если ЗначениеПараметра <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(ЗначениеПараметра, Параметр);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если ТипЗнч(НастройкиИсточник) = Тип("НастройкиВложенногоОбъектаКомпоновкиДанных") Тогда
		ЗаполнитьЗначенияСвойств(НастройкиПриемник, НастройкиИсточник);
		СкопироватьНастройкиКомпоновкиДанных(НастройкиПриемник.Настройки, НастройкиИсточник.Настройки);
		Return;
	КонецЕсли;
	
	// Копирование настроек
	Если ТипЗнч(НастройкиИсточник) = Тип("НастройкиКомпоновкиДанных") Тогда
		
		СкопироватьЭлементы(НастройкиПриемник.ПараметрыДанных,		НастройкиИсточник.ПараметрыДанных);
		СкопироватьЭлементы(НастройкиПриемник.ПользовательскиеПоля,	НастройкиИсточник.ПользовательскиеПоля);
		СкопироватьЭлементы(НастройкиПриемник.Отбор,				НастройкиИсточник.Отбор);
		СкопироватьЭлементы(НастройкиПриемник.Порядок,				НастройкиИсточник.Порядок);
		
	КонецЕсли;
	
	Если ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаКомпоновкиДанных")
	 ИЛИ ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаТаблицыКомпоновкиДанных")
	 ИЛИ ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаДиаграммыКомпоновкиДанных") Тогда
		
		СкопироватьЭлементы(НастройкиПриемник.ПоляГруппировки,	НастройкиИсточник.ПоляГруппировки);
		СкопироватьЭлементы(НастройкиПриемник.Отбор,			НастройкиИсточник.Отбор);
		СкопироватьЭлементы(НастройкиПриемник.Порядок,			НастройкиИсточник.Порядок);
		ЗаполнитьЗначенияСвойств(НастройкиПриемник,				НастройкиИсточник);
		
	КонецЕсли;
	
	СкопироватьЭлементы(НастройкиПриемник.Выбор,				НастройкиИсточник.Выбор);
	СкопироватьЭлементы(НастройкиПриемник.УсловноеОформление,	НастройкиИсточник.УсловноеОформление);
	ЗаполнитьЭлементы(НастройкиПриемник.ПараметрыВывода,		НастройкиИсточник.ПараметрыВывода);
	
	// Копирование структуры
	Если ТипЗнч(НастройкиИсточник) = Тип("НастройкиКомпоновкиДанных")
	 ИЛИ ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаКомпоновкиДанных") Тогда
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Structure Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Structure.Добавить(ТипЗнч(ЭлементСтруктурыИсточник));
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаТаблицыКомпоновкиДанных")
	 ИЛИ ТипЗнч(НастройкиИсточник) = Тип("ГруппировкаДиаграммыКомпоновкиДанных") Тогда
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Structure Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Structure.Добавить();
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипЗнч(НастройкиИсточник) = Тип("ТаблицаКомпоновкиДанных") Тогда
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Строки Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Строки.Добавить();
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Колонки Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Колонки.Добавить();
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипЗнч(НастройкиИсточник) = Тип("ДиаграммаКомпоновкиДанных") Тогда
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Серии Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Серии.Добавить();
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
		Для каждого ЭлементСтруктурыИсточник Из НастройкиИсточник.Точки Цикл
			ЭлементСтруктурыПриемник = НастройкиПриемник.Точки.Добавить();
			СкопироватьНастройкиКомпоновкиДанных(ЭлементСтруктурыПриемник, ЭлементСтруктурыИсточник);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры



#КонецОбласти

#Область Отладка

Function СериализоватьЗапросДляОтладки(ОбъектОтладки)
	StructureОбъекта = Новый Structure;

	StructureОбъекта.Вставить("Текст", ОбъектОтладки.Текст);

	StructureОбъекта.Вставить("Параметры", CopyRecursively(ОбъектОтладки.Параметры));

	Если ОбъектОтладки.МенеджерВременныхТаблиц <> Неопределено Тогда
		StructureВременныхТаблиц = UT_CommonServerCall.StructureВременныхТаблицМенеджераВременныхТаблиц(
			ОбъектОтладки.МенеджерВременныхТаблиц);
		StructureОбъекта.Вставить("ВременныеТаблицы", StructureВременныхТаблиц);
	КонецЕсли;

	Return StructureОбъекта;
EndFunction

Function СериализоватьСКДДляОтладки(СКД, НастройкиСКД, ВнешниеНаборыДанных)
	Return UT_CommonServerCall.СериализоватьОбъектСКДДляОтладки(СКД, НастройкиСКД, ВнешниеНаборыДанных);
EndFunction

Function СериализоватьОбъектБДДляОтладки(ОбъектОтладки)
	StructureОбъекта = Новый Structure;
	StructureОбъекта.Вставить("Объект", ОбъектОтладки);

	Return StructureОбъекта;
EndFunction

Function СериализоватьHTTPЗапросДляОтладки(ЗапросHTTP, СоединениеHTTP)
	StructureОбъекта = Новый Structure;
	StructureОбъекта.Вставить("АдресСервера", СоединениеHTTP.Сервер);
	StructureОбъекта.Вставить("Порт", СоединениеHTTP.Порт);
	StructureОбъекта.Вставить("ИспользоватьHTPPS", СоединениеHTTP.ЗащищенноеСоединение <> Неопределено);
	Если СоединениеHTTP.ЗащищенноеСоединение = Неопределено Тогда
		StructureОбъекта.Вставить("Протокол", "http");
	Иначе
		StructureОбъекта.Вставить("Протокол", "https");
	КонецЕсли;

	StructureОбъекта.Вставить("ПроксиСервер", СоединениеHTTP.Прокси.Сервер(StructureОбъекта.Протокол));
	StructureОбъекта.Вставить("ПроксиПорт", СоединениеHTTP.Прокси.Порт(StructureОбъекта.Протокол));
	StructureОбъекта.Вставить("ПроксиПользователь", СоединениеHTTP.Прокси.Пользователь(StructureОбъекта.Протокол));
	StructureОбъекта.Вставить("ПроксиПароль", СоединениеHTTP.Прокси.Пароль(StructureОбъекта.Протокол));
	StructureОбъекта.Вставить("ИспользоватьАутентификациюОС", СоединениеHTTP.Прокси.ИспользоватьАутентификациюОС(
		StructureОбъекта.Протокол));

	StructureОбъекта.Вставить("Запрос", ЗапросHTTP.АдресРесурса);
	StructureОбъекта.Вставить("ТелоЗапроса", ЗапросHTTP.ПолучитьТелоКакСтроку());
	StructureОбъекта.Вставить("Заголовки", UT_CommonClientServer.ПолучитьСтрокуЗаголовковHTTP(
		ЗапросHTTP.Заголовки));

	ДвоичныеДанныеТела = ЗапросHTTP.ПолучитьТелоКакДвоичныеДанные();
	StructureОбъекта.Вставить("ДвоичныеДанныеТела", ДвоичныеДанныеТела);
	StructureОбъекта.Вставить("ДвоичныеДанныеТелаСтрокой", Строка(ДвоичныеДанныеТела));

	StructureОбъекта.Вставить("ИмяФайлаЗапроса", ЗапросHTTP.ПолучитьИмяФайлаТела());

	Return StructureОбъекта;

EndFunction

Function СериализоватьОбъектДляОтладкиВСтруктуру(ОбъектОтладки, НастройкиСКДИлиСоединениеHTTP, ВнешниеНаборыДанных)
	ТипВсеСсылки = UT_CommonCached.ОписаниеТипаВсеСсылки();

	StructureОбъекта = Новый Structure;
	Если ТипВсеСсылки.СодержитТип(ТипЗнч(ОбъектОтладки)) Тогда
		StructureОбъекта = СериализоватьОбъектБДДляОтладки(ОбъектОтладки);
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("HTTPЗапрос") Тогда
		StructureОбъекта = СериализоватьHTTPЗапросДляОтладки(ОбъектОтладки, НастройкиСКДИлиСоединениеHTTP);
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("Запрос") Тогда
		StructureОбъекта = СериализоватьЗапросДляОтладки(ОбъектОтладки);
	ИначеЕсли ТипЗнч(ОбъектОтладки) = Тип("СхемаКомпоновкиДанных") Тогда
		StructureОбъекта = СериализоватьСКДДляОтладки(ОбъектОтладки, НастройкиСКДИлиСоединениеHTTP, ВнешниеНаборыДанных);
	КонецЕсли;

	Return StructureОбъекта;
EndFunction

Function ОтладитьОбъект(ОбъектДляОтладки, НастройкиСКДИлиСоединениеHTTP = Неопределено, ВнешниеНаборыДанных=Неопределено) Export
	ОткрыватьСразуКонсоль = Ложь;

#Если ТолстыйКлиентОбычноеПриложение Или ТолстыйКлиентУправляемоеПриложение Тогда
	ОткрыватьСразуКонсоль = Истина;
#КонецЕсли

	ТипВсеСсылки = UT_CommonCached.ОписаниеТипаВсеСсылки();
	СериализованныйОбъект = СериализоватьОбъектДляОтладкиВСтруктуру(ОбъектДляОтладки, НастройкиСКДИлиСоединениеHTTP, ВнешниеНаборыДанных);
	Если ТипВсеСсылки.СодержитТип(ТипЗнч(ОбъектДляОтладки)) Тогда
		ТипОбъектаОтладки = "ОбъектБазыДанных";
	ИначеЕсли ТипЗнч(ОбъектДляОтладки) = Тип("HTTPЗапрос") Тогда
		ТипОбъектаОтладки = "HTTPЗапрос";
	ИначеЕсли ТипЗнч(ОбъектДляОтладки) = Тип("Запрос") Тогда
		ТипОбъектаОтладки = "ЗАПРОС";
	ИначеЕсли ТипЗнч(ОбъектДляОтладки) = Тип("СхемаКомпоновкиДанных") Тогда
		ТипОбъектаОтладки = "СхемаКомпоновкиДанных";
	КонецЕсли;

	Если ОткрыватьСразуКонсоль Тогда
		ДанныеДляОтладки = ПоместитьВоВременноеХранилище(СериализованныйОбъект);
#Если Клиент Тогда

		UT_CommonClient.ОткрытьКонсольОтладки(ТипОбъектаОтладки, ДанныеДляОтладки);

#КонецЕсли
		Return Неопределено;
	Иначе
		Return UT_CommonServerCall.ЗаписатьДанныеДляОтладкиВСправочник(ТипОбъектаОтладки,
			СериализованныйОбъект);
	КонецЕсли;
EndFunction

Function КлючДанныхОбъектаДанныхОтладкиВХранилищеНастроек() Export
	Return "УИ_УниверсальныеИнструменты_ДанныеДляОтладки";
EndFunction

Function КлючОбъектаВХранилищеНастроек() Export
	Return "УИ_УниверсальныеИнструменты";
EndFunction

#КонецОбласти

#Область HTTPЗапросы

Function ЗаголовкиHTTPЗапросаИзСтроки(СтрокаЗаголовков) Export
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(СтрокаЗаголовков);

	Заголовки = Новый Соответствие;

	Для НомерСтроки = 1 По ТекстовыйДокумент.КоличествоСтрок() Цикл
		ЗаголовокСтр = ТекстовыйДокумент.ПолучитьСтроку(НомерСтроки);

		Если Не ValueIsFilled(ЗаголовокСтр) Тогда
			Продолжить;
		КонецЕсли;

		МассивЗаголовка = StrSplit(ЗаголовокСтр, ":");
		Если МассивЗаголовка.Количество() <> 2 Тогда
			Продолжить;
		КонецЕсли;

		Заголовки.Вставить(МассивЗаголовка[0], МассивЗаголовка[1]);

	КонецЦикла;

	Return Заголовки;
EndFunction

Function ПолучитьСтрокуЗаголовковHTTP(Заголовки) Export
	СтрокаЗаголовков = "";

	Для Каждого КлючЗначение Из Заголовки Цикл
		СтрокаЗаголовков = СтрокаЗаголовков + ?(ValueIsFilled(СтрокаЗаголовков), Символы.ПС, "") + КлючЗначение.Ключ
			+ ":" + КлючЗначение.Значение;
	КонецЦикла;

	Return СтрокаЗаголовков;
EndFunction

#КонецОбласти

#Область JSON

Function мПрочитатьJSON(Значение, ПрочитатьВСоответствие = Ложь) Export
#Если ВебКлиент Тогда
	Return UT_CommonServerCall.мПрочитатьJSON(Значение);
#Иначе
		ЧтениеJSON = Новый ЧтениеJSON;
		ЧтениеJSON.УстановитьСтроку(Значение);

		ДанныеДокументаJSON =ПрочитатьJSON(ЧтениеJSON,ПрочитатьВСоответствие);
		ЧтениеJSON.Закрыть();

		Return ДанныеДокументаJSON;
#КонецЕсли
EndFunction // ПрочитатьJSON()

Function мЗаписатьJSON(StructureДанных) Export
#Если ВебКлиент Тогда
	Return UT_CommonServerCall.мЗаписатьJSON(StructureДанных);
#Иначе

		ЗаписьJSON = Новый ЗаписьJSON;
		ЗаписьJSON.УстановитьСтроку();
		ЗаписатьJSON(ЗаписьJSON, StructureДанных);
		СериализованнаяСтрока = ЗаписьJSON.Закрыть();
		Return СериализованнаяСтрока;
#КонецЕсли

EndFunction // ЗаписатьJSON(
#КонецОбласти

#Область ПараметрыЗаписи

Function StructureПараметровЗаписиПоУмолчанию() Export
	ПараметрыЗаписи=Новый Structure;
	ПараметрыЗаписи.Вставить("БезАвторегистрацииИзменений", Ложь);
	ПараметрыЗаписи.Вставить("ЗаписьВРежимеЗагрузки", Ложь);
	ПараметрыЗаписи.Вставить("ПривелигированныйРежим", Ложь);
	ПараметрыЗаписи.Вставить("ИспользоватьДопСвойства", Ложь);
	ПараметрыЗаписи.Вставить("ДополнительныеСвойства", Новый Structure);
	ПараметрыЗаписи.Вставить("ИспользоватьПроцедуруПередЗаписью", Ложь);
	ПараметрыЗаписи.Вставить("ПроцедураПередЗаписью", "");

	Return ПараметрыЗаписи;
EndFunction

Function ПараметрыЗаписиДляВыводаНаФормуИнструмента() Export
	Массив=Новый Массив;
	Массив.Добавить("ЗаписьВРежимеЗагрузки");
	Массив.Добавить("ПривелигированныйРежим");
	Массив.Добавить("БезАвторегистрацииИзменений");

	Return Массив;
EndFunction

Function ПараметрыЗаписиФормы(Форма, ПрефиксРеквизитаФормы = "ПараметрЗаписи_") Export
	ПараметрыЗаписи=StructureПараметровЗаписиПоУмолчанию();

	Для Каждого КлючЗначение Из ПараметрыЗаписи Цикл
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Structure") Тогда
			Для Каждого Стр Из Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ] Цикл
				ПараметрыЗаписи[КлючЗначение.Ключ].Вставить(Стр.Ключ, Стр.Значение);
			КонецЦикла;
		Иначе
			ПараметрыЗаписи[КлючЗначение.Ключ]=Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ];
		КонецЕсли;
	КонецЦикла;
//	ЗаполнитьЗначенияСвойств(ПараметрыЗаписи, Форма);

	Return ПараметрыЗаписи;
EndFunction

Процедура УстановитьПараметрыЗаписиНаФорму(Форма, ПараметрыЗаписи, ПрефиксРеквизитаФормы = "ПараметрЗаписи_") Export
	Для Каждого КлючЗначение Из ПараметрыЗаписи Цикл
		Если ТипЗнч(КлючЗначение.Значение) = Тип("Structure") Тогда
			Для Каждого КЗ Из КлючЗначение.Значение Цикл
				НС=Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ].Добавить();
				НС.Ключ=КЗ.Ключ;
				НС.Значение=КЗ.Значение;
			КонецЦикла;
		Иначе
			Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ]=КлючЗначение.Значение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

#КонецОбласти
#Область ФайловыеФункции

#Область СКД

#КонецОбласти

// Получается индекс пиктограммы файла - индекс в картинке КоллекцияПиктограммФайлов.
Function ПолучитьИндексПиктограммыФайла(Знач РасширениеФайла) Export

	Если ТипЗнч(РасширениеФайла) <> Тип("Строка") Или IsBlankString(РасширениеФайла) Тогда

		Return 0;
	КонецЕсли;

	РасширениеФайла = РасширениеБезТочки(РасширениеФайла);

	Расширение = "." + НРег(РасширениеФайла) + ";";

	Если СтрНайти(".dt;.1cd;.cf;.cfu;", Расширение) <> 0 Тогда
		Return 6; // Файлы 1С.

	ИначеЕсли Расширение = ".mxl;" Тогда
		Return 8; // Табличный Файл.

	ИначеЕсли СтрНайти(".txt;.log;.ini;", Расширение) <> 0 Тогда
		Return 10; // Текстовый Файл.

	ИначеЕсли Расширение = ".epf;" Тогда
		Return 12; // Внешние обработки.

	ИначеЕсли СтрНайти(".ico;.wmf;.emf;", Расширение) <> 0 Тогда
		Return 14; // Картинки.

	ИначеЕсли СтрНайти(".htm;.html;.url;.mht;.mhtml;", Расширение) <> 0 Тогда
		Return 16; // HTML.

	ИначеЕсли СтрНайти(".doc;.dot;.rtf;", Расширение) <> 0 Тогда
		Return 18; // Файл Microsoft Word.

	ИначеЕсли СтрНайти(".xls;.xlw;", Расширение) <> 0 Тогда
		Return 20; // Файл Microsoft Excel.

	ИначеЕсли СтрНайти(".ppt;.pps;", Расширение) <> 0 Тогда
		Return 22; // Файл Microsoft PowerPoint.

	ИначеЕсли СтрНайти(".vsd;", Расширение) <> 0 Тогда
		Return 24; // Файл Microsoft Visio.

	ИначеЕсли СтрНайти(".mpp;", Расширение) <> 0 Тогда
		Return 26; // Файл Microsoft Visio.

	ИначеЕсли СтрНайти(".mdb;.adp;.mda;.mde;.ade;", Расширение) <> 0 Тогда
		Return 28; // База данных Microsoft Access.

	ИначеЕсли СтрНайти(".xml;", Расширение) <> 0 Тогда
		Return 30; // xml.

	ИначеЕсли СтрНайти(".msg;", Расширение) <> 0 Тогда
		Return 32; // Письмо электронной почты.

	ИначеЕсли СтрНайти(".zip;.rar;.arj;.cab;.lzh;.ace;", Расширение) <> 0 Тогда
		Return 34; // Архивы.

	ИначеЕсли СтрНайти(".exe;.com;.bat;.cmd;", Расширение) <> 0 Тогда
		Return 36; // Исполняемые файлы.

	ИначеЕсли СтрНайти(".grs;", Расширение) <> 0 Тогда
		Return 38; // Графическая схема.

	ИначеЕсли СтрНайти(".geo;", Расширение) <> 0 Тогда
		Return 40; // Географическая схема.

	ИначеЕсли СтрНайти(".jpg;.jpeg;.jp2;.jpe;", Расширение) <> 0 Тогда
		Return 42; // jpg.

	ИначеЕсли СтрНайти(".bmp;.dib;", Расширение) <> 0 Тогда
		Return 44; // bmp.

	ИначеЕсли СтрНайти(".tif;.tiff;", Расширение) <> 0 Тогда
		Return 46; // tif.

	ИначеЕсли СтрНайти(".gif;", Расширение) <> 0 Тогда
		Return 48; // gif.

	ИначеЕсли СтрНайти(".png;", Расширение) <> 0 Тогда
		Return 50; // png.

	ИначеЕсли СтрНайти(".pdf;", Расширение) <> 0 Тогда
		Return 52; // pdf.

	ИначеЕсли СтрНайти(".odt;", Расширение) <> 0 Тогда
		Return 54; // Open Office writer.

	ИначеЕсли СтрНайти(".odf;", Расширение) <> 0 Тогда
		Return 56; // Open Office math.

	ИначеЕсли СтрНайти(".odp;", Расширение) <> 0 Тогда
		Return 58; // Open Office Impress.

	ИначеЕсли СтрНайти(".odg;", Расширение) <> 0 Тогда
		Return 60; // Open Office draw.

	ИначеЕсли СтрНайти(".ods;", Расширение) <> 0 Тогда
		Return 62; // Open Office calc.

	ИначеЕсли СтрНайти(".mp3;", Расширение) <> 0 Тогда
		Return 64;

	ИначеЕсли СтрНайти(".erf;", Расширение) <> 0 Тогда
		Return 66; // Внешние отчеты.

	ИначеЕсли СтрНайти(".docx;", Расширение) <> 0 Тогда
		Return 68; // Файл Microsoft Word docx.

	ИначеЕсли СтрНайти(".xlsx;", Расширение) <> 0 Тогда
		Return 70; // Файл Microsoft Excel xlsx.

	ИначеЕсли СтрНайти(".pptx;", Расширение) <> 0 Тогда
		Return 72; // Файл Microsoft PowerPoint pptx.

	ИначеЕсли СтрНайти(".p7s;", Расширение) <> 0 Тогда
		Return 74; // Файл подписи.

	ИначеЕсли СтрНайти(".p7m;", Расширение) <> 0 Тогда
		Return 76; // зашифрованное сообщение.
	Иначе
		Return 4;
	КонецЕсли;

EndFunction

// Преобразует расширение файла в нижний регистр без точки.
//
// Параметры:
//  Расширение - Строка - Расширение для преобразования.
//
// Возвращаемое значение:
//  Строка.
//
Function РасширениеБезТочки(Знач Расширение) Export

	Расширение = НРег(СокрЛП(Расширение));

	Если Сред(Расширение, 1, 1) = "." Тогда
		Расширение = Сред(Расширение, 2);
	КонецЕсли;

	Return Расширение;

EndFunction

#КонецОбласти

#Область НастройкиИнструментов

Function КлючДанныхНастроекВХранилищеНастроек() Export
	Return "УИ_УниверсальныеИнструменты_Настройки";
EndFunction

Function КлючНастроекПараметровСеанса() Export
	Return "ПараметрыСеанса";
EndFunction

#КонецОбласти

#Область ПараметрыПоставки

Function ИмяФайлаСкачивания() Export
	Return "UI.cfe";
EndFunction

Function ВариантПоставки() Export
	Return "Расширение";
EndFunction

Function ВариантПоставкиПортативный() Export
	Return "Портативный";
EndFunction

Function Версия() Export
	Return "1.4.6";	
EndFunction

Function ЭтоПортативнаяПоставка() Export
	Return ВариантПоставки() = ВариантПоставкиПортативный();	
EndFunction

#КонецОбласти
////////////////////////////////////////////////////////////////////////
// English Code Area 


// Create copy of value type of Structure, Recursively, according of types of properties. 
// If  structure properties contains values of object types  (catalogref, DocumentRef,etc),
//  their contents are not copied, but references to the source object are returned..
//
// Parameters:
//  SourceStructure - Structure - copied Structure.
// 
// Return value:
//  Structure - copy of the original structure.
//
Function CopyStructure(SourceStructure) Export

	ResultStructure = New Structure;

	For Each  KeyAndValue Из SourceStructure Do
		ResultStructure.Insert(KeyAndValue.Key, CopyRecursively(KeyAndValue.Vakue));
	EndDo;

	Return ResultStructure;

EndFunction

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник - Structure - коллекция, в которую будут добавляться новые значения.
//   Источник - Structure - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Заменять - Булево, Неопределено - что делать в местах пересечения ключей источника и приемника:
//                                       Истина - заменять значения приемника (самый быстрый способ),
//                                       Ложь   - не заменять значения приемника (пропускать),
//                                       Неопределено - значение по умолчанию. Бросать исключение.
//
Процедура ДополнитьСтруктуру(Приемник, Источник, Заменять = Неопределено) Export

	Для Каждого Элемент Из Источник Цикл
		Если Заменять <> Истина И Приемник.Свойство(Элемент.Ключ) Тогда
			Если Заменять = Ложь Тогда
				Продолжить;
			Иначе
				ВызватьИсключение СтрШаблон(НСтр("ru = 'Пересечение ключей источника и приемника: ""%1"".'"),
					Элемент.Ключ);
			КонецЕсли;
		КонецЕсли;
		Приемник.Вставить(Элемент.Ключ, Элемент.Значение);
	КонецЦикла;

КонецПроцедуры

// Создает полную копию структуры, соответствия, массива, списка или таблицы значений, рекурсивно, 
// с учетом типов дочерних элементов. При этом содержимое значений объектных типов 
// (СправочникОбъект, ДокументОбъект и т.п.) не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  Источник - Structure, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - объект, который необходимо 
//             скопировать.
//
// Возвращаемое значение:
//  Structure, Соответствие, Массив, СписокЗначений, ТаблицаЗначений - копия объекта, переданного в параметре Источник.
//
Function CopyRecursively(Источник) Export

	Перем Приемник;

	ТипИсточника = ТипЗнч(Источник);

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	Если ТипИсточника = Тип("ТаблицаЗначений") Тогда
		Return Источник.Скопировать();
	КонецЕсли;
#КонецЕсли
	Если ТипИсточника = Тип("Structure") Тогда
		Приемник = CopyStructure(Источник);
	ИначеЕсли ТипИсточника = Тип("Соответствие") Тогда
		Приемник = СкопироватьСоответствие(Источник);
	ИначеЕсли ТипИсточника = Тип("Массив") Тогда
		Приемник = СкопироватьМассив(Источник);
	ИначеЕсли ТипИсточника = Тип("СписокЗначений") Тогда
		Приемник = СкопироватьСписокЗначений(Источник);
	Иначе
		Приемник = Источник;
	КонецЕсли;

	Return Приемник;

EndFunction

// Создает копию значения типа Соответствие, рекурсивно, с учетом типов значений.
// Если значения соответствия содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СоответствиеИсточник - Соответствие - соответствие, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Соответствие - копия исходного соответствия.
//
Function СкопироватьСоответствие(СоответствиеИсточник) Export

	СоответствиеРезультат = Новый Соответствие;

	Для Каждого КлючИЗначение Из СоответствиеИсточник Цикл
		СоответствиеРезультат.Вставить(КлючИЗначение.Ключ, CopyRecursively(КлючИЗначение.Значение));
	КонецЦикла;

	Return СоответствиеРезультат;

EndFunction

// Создает копию значения типа Массив, рекурсивно, с учетом типов значений элементов массива.
// Если элементы массива содержат значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  МассивИсточник - Массив - массив, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  Массив - копия исходного массива.
//
Function СкопироватьМассив(МассивИсточник) Export

	МассивРезультат = Новый Массив;

	Для Каждого Элемент Из МассивИсточник Цикл
		МассивРезультат.Добавить(CopyRecursively(Элемент));
	КонецЦикла;

	Return МассивРезультат;

EndFunction

// Создает копию значения типа СписокЗначений, рекурсивно, с учетом типов его значений.
// Если в списке значений есть значения объектных типов (СправочникОбъект, ДокументОбъект и т.п.),
// то их содержимое не копируются, а возвращаются ссылки на исходный объект.
//
// Параметры:
//  СписокИсточник - СписокЗначений - список значений, копию которого необходимо получить.
// 
// Возвращаемое значение:
//  СписокЗначений - копия исходного списка значений.
//
Function СкопироватьСписокЗначений(СписокИсточник) Export

	СписокРезультат = Новый СписокЗначений;

	Для Каждого ЭлементСписка Из СписокИсточник Цикл
		СписокРезультат.Добавить(CopyRecursively(ЭлементСписка.Значение), ЭлементСписка.Представление,
			ЭлементСписка.Пометка, ЭлементСписка.Картинка);
	КонецЦикла;

	Return СписокРезультат;

EndFunction

// Преобразует РасписаниеРегламентногоЗадания в структуру.
//
// Параметры:
//  Расписание - РасписаниеРегламентногоЗадания - исходное расписание.
// 
// Возвращаемое значение:
//  Structure - расписание в виде структуры.
//
Function РасписаниеВСтруктуру(Знач Расписание) Export

	ЗначениеРасписания = Расписание;
	Если ЗначениеРасписания = Неопределено Тогда
		ЗначениеРасписания = Новый РасписаниеРегламентногоЗадания;
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце,"
		+ "ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый Structure(СписокПолей);
	ЗаполнитьЗначенияСвойств(Результат, ЗначениеРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для Каждого РасписаниеДля Из Расписание.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(РасписаниеВСтруктуру(РасписаниеДля));
	КонецЦикла;
	Результат.Вставить("ДетальныеРасписанияДня", ДетальныеРасписанияДня);
	Return Результат;

EndFunction

// Преобразует структуру в РасписаниеРегламентногоЗадания.
//
// Параметры:
//  StructureРасписания - Structure - расписание в виде структуры.
// 
// Возвращаемое значение:
//  РасписаниеРегламентногоЗадания - расписание.
//
Function StructureВРасписание(Знач StructureРасписания) Export

	Если StructureРасписания = Неопределено Тогда
		Return Новый РасписаниеРегламентногоЗадания;
	КонецЕсли;
	СписокПолей = "ВремяЗавершения,ВремяКонца,ВремяНачала,ДатаКонца,ДатаНачала,ДеньВМесяце,ДеньНеделиВМесяце,"
		+ "ДниНедели,ИнтервалЗавершения,Месяцы,ПаузаПовтора,ПериодНедель,ПериодПовтораВТечениеДня,ПериодПовтораДней";
	Результат = Новый РасписаниеРегламентногоЗадания;
	ЗаполнитьЗначенияСвойств(Результат, StructureРасписания, СписокПолей);
	ДетальныеРасписанияДня = Новый Массив;
	Для Каждого Расписание Из StructureРасписания.ДетальныеРасписанияДня Цикл
		ДетальныеРасписанияДня.Добавить(StructureВРасписание(Расписание));
	КонецЦикла;
	Результат.ДетальныеРасписанияДня = ДетальныеРасписанияДня;
	Return Результат;

EndFunction

// Вызывает исключение, если тип значения параметра ИмяПараметра процедуры или функции ИмяПроцедурыИлиФункции
// отличается от ожидаемого.
// Для диагностики типов параметров, передаваемых в процедуры и функции программного интерфейса.
//
// Параметры:
//   ИмяПроцедурыИлиФункции - Строка             - имя процедуры или функции, параметр которой проверяется.
//   ИмяПараметра           - Строка             - имя проверяемого параметра процедуры или функции.
//   ЗначениеПараметра      - Произвольный       - фактическое значение параметра.
//   ОжидаемыеТипы  - ОписаниеТипов, Тип, Массив - тип(ы) параметра процедуры или функции.
//   ОжидаемыеТипыСвойств   - Structure          - если ожидаемый тип - Structure, то 
//                                                 в этом параметре можно указать типы ее свойств.
//
Процедура ПроверитьПараметр(Знач ИмяПроцедурыИлиФункции, Знач ИмяПараметра, Знач ЗначениеПараметра, Знач ОжидаемыеТипы,
	Знач ОжидаемыеТипыСвойств = Неопределено) Export

	Контекст = "ОбщегоНазначенияКлиентСервер.ПроверитьПараметр";
	Проверить(ТипЗнч(ИмяПроцедурыИлиФункции) = Тип("Строка"), НСтр(
		"ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);
	Проверить(ТипЗнч(ИмяПараметра) = Тип("Строка"), НСтр("ru = 'Недопустимо значение параметра ИмяПараметра'"),
		Контекст);

	ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеПараметра, ОжидаемыеТипы);
	Проверить(ЭтоКорректныйТип <> Неопределено, НСтр("ru = 'Недопустимо значение параметра ОжидаемыеТипы'"), Контекст);

	НедопустимыйПараметр = НСтр("ru = 'Недопустимое значение параметра %1 в %2. 
								|Ожидалось: %3; передано значение: %4 (тип %5).'");
	Проверить(ЭтоКорректныйТип, СтрШаблон(НедопустимыйПараметр, ИмяПараметра, ИмяПроцедурыИлиФункции,
		ПредставлениеТипов(ОжидаемыеТипы), ?(ЗначениеПараметра <> Неопределено, ЗначениеПараметра, НСтр(
		"ru = 'Неопределено'")), ТипЗнч(ЗначениеПараметра)));

	Если ТипЗнч(ЗначениеПараметра) = Тип("Structure") И ОжидаемыеТипыСвойств <> Неопределено Тогда

		Проверить(ТипЗнч(ОжидаемыеТипыСвойств) = Тип("Structure"), НСтр(
			"ru = 'Недопустимо значение параметра ИмяПроцедурыИлиФункции'"), Контекст);

		НетСвойства = НСтр("ru = 'Недопустимое значение параметра %1 (Structure) в %2. 
						   |В структуре ожидалось свойство %3 (тип %4).'");
		НедопустимоеСвойство = НСтр("ru = 'Недопустимое значение свойства %1 в параметре %2 (Structure) в %3. 
									|Ожидалось: %4; передано значение: %5 (тип %6).'");
		Для Каждого Свойство Из ОжидаемыеТипыСвойств Цикл

			ОжидаемоеИмяСвойства = Свойство.Ключ;
			ОжидаемыйТипСвойства = Свойство.Значение;
			ЗначениеСвойства = Неопределено;

			Проверить(ЗначениеПараметра.Свойство(ОжидаемоеИмяСвойства, ЗначениеСвойства), СтрШаблон(НетСвойства,
				ИмяПараметра, ИмяПроцедурыИлиФункции, ОжидаемоеИмяСвойства, ОжидаемыйТипСвойства));

			ЭтоКорректныйТип = ЗначениеОжидаемогоТипа(ЗначениеСвойства, ОжидаемыйТипСвойства);
			Проверить(ЭтоКорректныйТип, СтрШаблон(НедопустимоеСвойство, ОжидаемоеИмяСвойства, ИмяПараметра,
				ИмяПроцедурыИлиФункции, ПредставлениеТипов(ОжидаемыеТипы), ?(ЗначениеСвойства <> Неопределено,
				ЗначениеСвойства, НСтр("ru = 'Неопределено'")), ТипЗнч(ЗначениеСвойства)));
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// Вызывает исключение с текстом Сообщение, если Условие не равно Истина.
// Применяется для самодиагностики кода.
//
// Параметры:
//   Условие                - Булево - если не равно Истина, то вызывается исключение.
//   КонтекстПроверки       - Строка - например, имя процедуры или функции, в которой выполняется проверка.
//   Сообщение              - Строка - текст сообщения. Если не задан, то исключение вызывается с сообщением по
//                                     умолчанию.
//
Процедура Проверить(Знач Условие, Знач Сообщение = "", Знач КонтекстПроверки = "") Export

	Если Условие <> Истина Тогда
		Если IsBlankString(Сообщение) Тогда
			ТекстИсключения = НСтр("ru = 'Недопустимая операция'"); // Assertion failed
		Иначе
			ТекстИсключения = Сообщение;
		КонецЕсли;
		Если Не IsBlankString(КонтекстПроверки) Тогда
			ТекстИсключения = ТекстИсключения + " " + СтрШаблон(НСтр("ru = 'в %1'"), КонтекстПроверки);
		КонецЕсли;
		ВызватьИсключение ТекстИсключения;
	КонецЕсли;

КонецПроцедуры

Function ПредставлениеТипов(ОжидаемыеТипы)
	Если ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Тогда
		Результат = "";
		Индекс = 0;
		Для Каждого Тип Из ОжидаемыеТипы Цикл
			Если Не IsBlankString(Результат) Тогда
				Результат = Результат + ", ";
			КонецЕсли;
			Результат = Результат + ПредставлениеТипа(Тип);
			Индекс = Индекс + 1;
			Если Индекс > 10 Тогда
				Результат = Результат + ",... " + СтрШаблон(НСтр("ru='(всего %1 типов)'"), ОжидаемыеТипы.Количество());
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Return Результат;
	Иначе
		Return ПредставлениеТипа(ОжидаемыеТипы);
	КонецЕсли;
EndFunction

Function ПредставлениеТипа(Тип)
	Если Тип = Неопределено Тогда
		Return "Неопределено";
	ИначеЕсли ТипЗнч(Тип) = Тип("ОписаниеТипов") Тогда
		ТипСтрокой = Строка(Тип);
		Return ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + "..." + СтрШаблон(НСтр("ru='(всего %1 типов)'"),
			Тип.Типы().Количество()), ТипСтрокой);
	Иначе
		ТипСтрокой = Строка(Тип);
		Return ?(СтрДлина(ТипСтрокой) > 150, Лев(ТипСтрокой, 150) + "...", ТипСтрокой);
	КонецЕсли;
EndFunction

Function ЗначениеОжидаемогоТипа(Значение, ОжидаемыеТипы)
	ТипЗначения = ТипЗнч(Значение);
	Если ТипЗнч(ОжидаемыеТипы) = Тип("ОписаниеТипов") Тогда
		Return ОжидаемыеТипы.Типы().Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Тип") Тогда
		Return ТипЗначения = ОжидаемыеТипы;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Массив") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированныйМассив") Тогда
		Return ОжидаемыеТипы.Найти(ТипЗначения) <> Неопределено;
	ИначеЕсли ТипЗнч(ОжидаемыеТипы) = Тип("Соответствие") Или ТипЗнч(ОжидаемыеТипы) = Тип("ФиксированноеСоответствие") Тогда
		Return ОжидаемыеТипы.Получить(ТипЗначения) <> Неопределено;
	КонецЕсли;
	Return Неопределено;
EndFunction

Процедура ДобавитьМассивОбъектовКСравнению(Объекты) Export
	UT_CommonServerCall.ДобавитьМассивОбъектовКСравнению(Объекты);
КонецПроцедуры

// Возвращает код основного языка конфигурации, например "ru".
//
// Возвращаемое значение:
//  Строка - код языка.
//
Function КодОсновногоЯзыка() Export
#Если Не ТонкийКлиент И Не ВебКлиент И Не МобильныйКлиент Тогда
	Return Метаданные.ОсновнойЯзык.КодЯзыка;
#Иначе
		Return UT_CommonCached.КодОсновногоЯзыка();
#КонецЕсли
EndFunction

// Получает ссылку предопределенного элемента по его полному имени.
// Предопределенные элементы могут содержаться только в следующих объектах:
//   - Справочники;
//   - Планы видов характеристик;
//   - Планы счетов;
//   - Планы видов расчета.
//
// Параметры:
//   ПолноеИмяПредопределенного - Строка - Полный путь к предопределенному элементу, включая его имя.
//     Формат аналогичен функции глобального контекста ПредопределенноеЗначение().
//     Например:
//       "Справочник.ВидыКонтактнойИнформации.EmailПользователя"
//       "ПланСчетов.Хозрасчетный.Материалы"
//       "ПланВидовРасчета.Начисления.ОплатаПоОкладу".
//
// Возвращаемое значение: 
//   ЛюбаяСсылка - ссылка на предопределенный элемент.
//   Неопределено - если предопределенный есть в метаданных, но не создан в ИБ.
//
Function ПредопределенныйЭлемент(ПолноеИмяПредопределенного) Export

// Используется стандартная Function платформы для получения:
	//  - пустых ссылок; 
	//  - значений перечислений;
	//  - точек маршрута бизнес-процессов.
	Если ".ПУСТАЯССЫЛКА" = ВРег(Прав(ПолноеИмяПредопределенного, 13)) Или "ПЕРЕЧИСЛЕНИЕ." = ВРег(Лев(
		ПолноеИмяПредопределенного, 13)) Или "БИЗНЕСПРОЦЕСС." = ВРег(Лев(ПолноеИмяПредопределенного, 14)) Тогда

		Return ПредопределенноеЗначение(ПолноеИмяПредопределенного);
	КонецЕсли;

	// Разбор полного имени предопределенного.
	ЧастиПолногоИмени = StrSplit(ПолноеИмяПредопределенного, ".");
	Если ЧастиПолногоИмени.Количество() <> 3 Тогда
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;

	ПолноеИмяОбъектаМетаданных = ВРег(ЧастиПолногоИмени[0] + "." + ЧастиПолногоИмени[1]);
	ИмяПредопределенного = ЧастиПолногоИмени[2];

	// В зависимости от контекста выполняется обращение к разному кэшу.

#Если Сервер Или ТолстыйКлиентОбычноеПриложение Или ВнешнееСоединение Тогда
	ПредопределенныеЗначения = UT_CommonCached.СсылкиПоИменамПредопределенных(ПолноеИмяОбъектаМетаданных);
#Иначе
		ПредопределенныеЗначения = UT_CommonClientCached.СсылкиПоИменамПредопределенных(
			ПолноеИмяОбъектаМетаданных);
#КонецЕсли

	// Если ошибка в имени метаданных.
	Если ПредопределенныеЗначения = Неопределено Тогда
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;

	// Получение результата из кэша.
	Результат = ПредопределенныеЗначения.Получить(ИмяПредопределенного);

	// Если предопределенного нет в метаданных.
	Если Результат = Неопределено Тогда
		ВызватьИсключение ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного);
	КонецЕсли;

	// Если предопределенный есть в метаданных, но не создан в ИБ.
	Если Результат = Null Тогда
		Return Неопределено;
	КонецЕсли;

	Return Результат;

EndFunction

Function ТекстОшибкиПредопределенноеЗначениеНеНайдено(ПолноеИмяПредопределенного)

	Return СтрШаблон(НСтр("ru = 'Предопределенное значение ""%1"" не найдено.'"), ПолноеИмяПредопределенного);

EndFunction

Function ИмяПараметраОтмененныхДлительныхОпераций(Параметры) Export

	Return "УИ_ОтмененныеДлительныеОперации";
EndFunction

// Возвращает значение свойства структуры.
//
// Параметры:
//   Structure - Structure, ФиксированнаяStructure - Объект, из которого необходимо прочитать значение ключа.
//   Ключ - Строка - Имя свойства структуры, для которого необходимо прочитать значение.
//   ЗначениеПоУмолчанию - Произвольный - Необязательный. Возвращается когда в структуре нет значения по указанному
//                                        ключу.
//       Для скорости рекомендуется передавать только быстро вычисляемые значения (например примитивные типы),
//       а инициализацию более тяжелых значений выполнять после проверки полученного значения (только если это
//       требуется).
//
// Возвращаемое значение:
//   Произвольный - Значение свойства структуры. ЗначениеПоУмолчанию если в структуре нет указанного свойства.
//
Function СвойствоСтруктуры(Structure, Ключ, ЗначениеПоУмолчанию = Неопределено) Export

	Если Structure = Неопределено Тогда
		Return ЗначениеПоУмолчанию;
	КонецЕсли;

	Результат = ЗначениеПоУмолчанию;
	Если Structure.Свойство(Ключ, Результат) Тогда
		Return Результат;
	Иначе
		Return ЗначениеПоУмолчанию;
	КонецЕсли;

EndFunction

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(Знач ТекстСообщенияПользователю, Знач КлючДанных = Неопределено, Знач Поле = "",
	Знач ПутьКДанным = "", Отказ = Ложь) Export

	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;

	ЭтоОбъект = Ложь;

#Если Не ТонкийКлиент И Не ВебКлиент Тогда
	Если КлючДанных <> Неопределено И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли

	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;

	Если Не IsBlankString(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;

	Сообщение.Сообщить();

	Отказ = Истина;

КонецПроцедуры

// Дополняет массив МассивПриемник значениями из массива МассивИсточник.
//
// Параметры:
//  МассивПриемник - Массив - массив, в который необходимо добавить значения.
//  МассивИсточник - Массив - массив значений для заполнения.
//  ТолькоУникальныеЗначения - Булево - если истина, то в массив будут включены только уникальные значения.
//
Процедура ДополнитьМассив(МассивПриемник, МассивИсточник, ТолькоУникальныеЗначения = Ложь) Export

	Если ТолькоУникальныеЗначения Тогда

		УникальныеЗначения = Новый Соответствие;

		Для Каждого Значение Из МассивПриемник Цикл
			УникальныеЗначения.Вставить(Значение, Истина);
		КонецЦикла;

		Для Каждого Значение Из МассивИсточник Цикл
			Если УникальныеЗначения[Значение] = Неопределено Тогда
				МассивПриемник.Добавить(Значение);
				УникальныеЗначения.Вставить(Значение, Истина);
			КонецЕсли;
		КонецЦикла;

	Иначе

		Для Каждого Значение Из МассивИсточник Цикл
			МассивПриемник.Добавить(Значение);
		КонецЦикла;

	КонецЕсли;

КонецПроцедуры

Function IsWindows() Export
	SystemInfo = Новый SystemInfo;
	Return SystemInfo.PlatformType = PlatformType.Windows_x86 Или SystemInfo.PlatformType
		= PlatformType.Windows_x86_64;
EndFunction

Function IsLinux() Export
	SystemInfo = New SystemInfo;
	Return SystemInfo.PlatformType = PlatformType.Linux_x86 Или SystemInfo.PlatformType
		= PlatformType.Linux_x86_64;
EndFunction

Function PlatformVersionNotLess_8_3_14() Export
	Return PlatformVersionNotLess("8.3.14");
EndFunction

Function PlatformVersionNotLess(ComparingVersion) Export
	VersionWithOutReleaseSubnumber=ConfigurationVersionWithOutReleaseSubnumber(CurrentAppVersion());

	Return CompareVersionsWithOutReleaseSubnumber(VersionWithOutReleaseSubnumber, ComparingVersion)>=0;
EndFunction

Function HTMLFieldBasedOnWebkit() Export
	Return PlatformVersionNotLess_8_3_14() OR IsLinux()
EndFunction

#Region Variables
Function IsCorrectVariableName(Name) Export
	If Not ValueIsFilled(Name) Then
		Return False;
	EndIf;
	IsCorrectName = False;
	Try
		TempVar = New Structure(Name);
		IsCorrectName=True;
	Except
	EndTry;
	
	Return IsCorrectName;
EndFunction

Function WrongVariableNameWarningText() Export
	Return NStr("ru='Неверное имя колонки! Имя должно состоять из одного слова, начинаться с буквы и не содержать специальных символов кроме ""_""."";
				|en='Invalid column name! The name must consist of a single word, start with a letter and contain no special characters other than ""_"".""'
				|");
EndFunction

#EndRegion
#Region DynamicList
#EndRegion
#Region Debug
#EndRegion
#Region HTTPRequests
#EndRegion
#Region JSON
#EndRegion

// Returns 1C:Enterprise current version.
//
Function CurrentAppVersion() Export

	SystemInfo = New SystemInfo;
	Return SystemInfo.AppVersion;

EndFunction

// Get configuration version number without build number (Release subnumber).
//
// Params:
//  Version - String - configuration version as PV.MV.R.RS,
//                    where RS - Release subnumber, that will be deleted.
//                    PV - <primary version>, MV - <minor version>, R - <release>
// 
// Return Value:
//  String - configuration version number without  Release subnumber -  PV.MV.R
//
Function ConfigurationVersionWithOutReleaseSubnumber(Val Version) Export

	Array = StrSplit(Version, ".");

	If Array.Count() < 3 Then
		Return Version;
	EndIf;

	Result = "[Primary].[Minor].[Release]";
	Result = StrReplace(Result, "[Primary]", Array[0]);
	Result = StrReplace(Result, "[Minor]", Array[1]);
	Result = StrReplace(Result, "[Release]", Array[2]);

	Return Result;
EndFunction

// Compare two strings that contains version info
//
// Parameters:
//  Version1String  - String - number of version in  РР.{M|MM}.RR.RS format
//  Version2String  - String - secound compared version number.
//
// Return Value значение:
//   Integer   - more than 0, if Version1String > Version2String; 0, if version values is equal.
//
Function CompareVersions(Val Version1String, Val Version2String) Export

	String1 = ?(IsBlankString(Version1String), "0.0.0.0", Version1String);
	String2 = ?(IsBlankString(Version2String), "0.0.0.0", Version2String);
	Version1 = StrSplit(String1, ".");
	If Version1.Count() <> 4 Then
		Raise StrTemplate(NStr("ru = 'Неправильный формат параметра Version1String: %1'; en='Wrong format of parameter Version1String: %1'"), Version1String);
	EndIf;
	Version2 = StrSplit(String2, ".");
	If Version2.Count() <> 4 Then
		Raise StrTemplate(NStr("ru = 'Неправильный формат параметра Version2String: %1'; en='Wrong format of parameter Version2String: %1'"), Version2String);
	EndIf;

	Result = 0;
	For Digit = 0 to 3 do
		Result = Number(Version2[Digit]) - Number(Version2[Digit]);
		If Result <> 0 Then
			Return Result;
		EndIf;
	EndDo;
	Return Result;

EndFunction

// Compare two strings that contains version info
//
// Parameters:
//  Version1String  - String - number of version in  РР.{M|MM}.RR format
//  Version2String  - String - secound compared version number.
//
// Return Value значение:
//   Integer   - more than 0, if Version1String > Version2String; 0, if version values is equal.
//
//
Function CompareVersionsWithOutReleaseSubnumber(Val Version1String, Val Version2String) Export

	String1 = ?(IsBlankString(Version1String), "0.0.0", Version1String);
	String2 = ?(IsBlankString(Version2String), "0.0.0", Version2String);
	Version1 = StrSplit(String1, ".");
	If Version1.Count() <> 3 Then
		Raise StrTemplate(NStr("ru = 'Неправильный формат параметра Version1String: %1'; en='Wrong format of parameter Version1String: %1'"), Version1String);
	EndIf;
	Version2 = StrSplit(String2, ".");
	If Version2.Count() <> 3 Then
		Raise StrTemplate(NStr("ru = 'Неправильный формат параметра Version2String: %1'; en='Wrong format of parameter Version2String: %1'"), Version2String);
	EndIf;

	Result = 0;
	For Digit = 0 to 2 do
		Result = Number(Version1[Digit]) - Number(Version2[Digit]);
		If Result <> 0 Then
			Return Result;
		EndIf;
	КонецЦикла;
	Return Result;

EndFunction


#Region WriteParams

#EndRegion

#Region FileFunctions

#EndRegion

#Region ToolsSettings

#EndRegion

#Region DistributionSettings

#EndRegion


Function ManagedFormType() Export
	If PlatformVersionNotLess_8_3_14() Then
		Return Type("ClientApplicationForm")
	Else
		Return Type("ManagedForm");
	EndIf;
EndFunction

Function ToolsFormOutputWriteSettings() Export
	Array=New Array;
	Array.Add("WritingInLoadMode");    
	Array.Add("PrivilegedMode");     
	Array.Add("WithOutChangeRecording");

	Return Array;
EndFunction

Function FormWriteSettings(Форма, ПрефиксРеквизитаФормы = "ПараметрЗаписи_") Export
	WriteSettings=StructureПараметровЗаписиПоУмолчанию();

	For each КлючЗначение In WriteSettings Do
		If ТипЗнч(КлючЗначение.Значение) = Тип("Structure") Then
			For Each Стр In Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ] Do
				WriteSettings[КлючЗначение.Ключ].Вставить(Стр.Ключ, Стр.Значение);
			EndDo;
		Else
			WriteSettings[КлючЗначение.Ключ]=Форма[ПрефиксРеквизитаФормы + КлючЗначение.Ключ];
		EndIf;
	EndDo;
//	ЗаполнитьЗначенияСвойств(ПараметрыЗаписи, Форма);
	Return WriteSettings;
EndFunction



